1. 컴파일이란
    - 인간이 이해할 수 있는 언어로 작성된 소스 코드를 CPU가 이해할 수 있는 언어 (기계어)로 번역하는 작업
    - 소스 코드는 컴파일을 통해 기계어로 이루어진 실행 파일 내용이 운영체제에 의해 메모리에 적재되어 프로그램이 동작함
    - C 언어 컴파일의 4 단계![img.png](img%2Fimg.png)
    1. 전처리 과정
       - 전처리기를 통해 소스 코드 파일 ( *.c)을 전처리된 소스 코드 파일( *.i )로 변환하는 과정
       - 주석 제거, 헤더 파일 삽입(#include), 메크로 치환 및 적용(#define) 작업 수행
   2. 컴파일 과정
       - 컴파일러(Compiler)를 통해 전처리된 소스 코드 파일(*.i)을 어셈블리어 파일(*.s)로 변환하는 과정
       - 언어의 문법 검사 수행, Static 영역들의 메모리 할당 수행
       - 컴파일러는 프론트 엔드, 미들엔드, 백엔드로 구성되어 있다![img_1.png](img%2Fimg_1.png)
         - 프론트엔드 : 소스코드가 해당언어로 잘 작성되었는지 확인 후 GIMPLE트리(소스코드를 트리 형태로 표현한 자료구)를 생성하여 미들엔드로 넘김
         - 미들엔드 : CPU 아키텍처가 무엇이든 상관없이 사용할 수 있도록 아키텍처 비종속적이 최적화를 하고 RTL(Register Transfer Language:고급언어와 어셈블리어의 중간 언어)를 생성 후 백엔드로 넘김
         - 백엔드 : CPU 아키텍쳐 별로 성능을 높이기 위해 아키텍처 종속적인 최적화를 진행하며 RTL을 이용하여 어셈블리 코드를 생성한다
   3. 어셈블리 과정
      - 어셈블러(Assembler)를 통해 어셈블리어 파일( *.s)을 오브젝트 파일( *.o)로 변환하는 과정
      - 어셈블리어 : 기계어와 일대일 대응되며 사람이 이해할 수 있도록 부호화한 컴퓨터의 저급 언어
      - 오브젝트 파일 : 더 이상 사람이 알아볼 수 없는 기계어인 오브젝트 코드로 구성 된 파
   4. 링킹 과정
       - 링커(Linker)를 통해 오브젝트 파일(*.o)들을 묶어 실행 파일로 만드는 과정
       - 오브젝트 파일들과 프로그램에서 사용하는 라이브러리 파일들을 링크하여 하나의 실행 파일로 만듦
       - 링커는 심볼해석(symbol resolution : 여러개의 오브젝트 파일에 같은 이름의 함수 또는 변수가 정의되어 있을 때 어떤 파일의 어떤 함수를 사용할지 결정하는 과정)과 재배치 (relocation : 데이터의 주소나 코드의 메모리 참조 주소를 알맞게 배치하는 과정) 를 하여 실행 가능한 오브젝트 파일을 생성

2. JVM(Java Virtual Machine) 이란
    - 자바를 실행하는 머신 → 자바를 돌리는 프로그램
    - 프로그래밍 언어를 기계어로 컴파일해주는 컴파일러
    - C언어와의 비교
        - C 언어(WOCA :Write Once, Compile Anywhere) : 특정 OS나 CPU 구조에 맞춰진 컴파일러에 의해 다르게 컴파일 됨 → 이식성이 낮다, 속도가 빠르다
        - Java (WORA : Write Once, Run Anywhere) : Java 로 작성된 코드는 JVM 을 거쳐서 운영체제와 상호작용을 함 → 운영체제로부터 독립적으로 프로그램을 제약없이 실행 할 수 있음, JVM 을 한번 더 거쳐야 하므로 실행 속도가 상대적으로 느림
    - JVM 구조![img_2.png](img%2Fimg_2.png)
        - 클래스 로더
          - *.class 파일을 동적으로 로드하여 JVM의 메모리 영역인 Runtime Data Areas에 배치
          - 어플리케이션에서 필요한 경우 동적으로 메모리에 적재
          - 파일 로딩 순서
              1. loading : 클래스 파일을 가져와서 JVM의 메모리에 로드
              2. linking : 클래스 파일을 사용하기 위해 검증
                  1. verifying : 읽어들인 클래스가 JVM 명세대로 구성되어 있는지 검사
                  2. preparing : 클래스가 필요로 하는 메모리 할당
                  3. resolving : 클래스 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경
              3. Initaliztion : 클래스 변수들을 적절한 값으로 초기화
      - 실행 엔진
          - 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행
          - 방식 : 인터프리터, JIT 컴파일러
              - 인터프리터 : 명령어를 하나씩 읽어서 해석하고 바로 실행, 기본적으로 인터프리터 방식을 사용하나 반복되는 코드인 경우 속도 저하로 JIT 컴파일러 방식을 사용
              - JIT 컴파일러(Just-In-Time Compiler) : 반복 코드를 발견하여 바이트 코드 전체를 컴파일하여 Native Code로 변경하여 캐싱 후 반복 코드 발생시 네이티브 코드로 직접 수행
      - 가비지 컬렉터
          - Heap 영역에서 사용하지 않는 메모리를 자동으로 회수
      - 런타임 데이터 영역![img_3.png](img%2Fimg_3.png)
        - 자바 애플리케이션 실행 시 사용되는 데이터들을 적재하는 영역
        - 메서드 영역
            - 모든 쓰레드가 공유하는 영역
            - 바이트 코드 (.class)를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간
            - JVM 시작 후 클래스가 로드될 때 적재되어 프로그램 종료 때까지 저장
            - runtime constant pool : 클래스 생성시 참조해야할 정보들을 상수로 가지고 있는 영역
            - field info (멤버 변수의 이름, 데이터 타입, 접근제어자 정보),  Method type(메서드 이름, return 타입, 함수 매개변수, 접근제어자 정보), type info(class/interface, type 속성, type 이름, super class 이름)
        - 힙 영역
            - 모든 쓰레드가 공유하는 영역
            - 데이터 저장을 위해 런타임시 동적으로 할당하여 사용하는 영역
            - new 연산자로 생성되는 클래스와 reference type
        - 스택 영역
            - 기본 자료형을 생성할 때 저장되는 공간으로 임시적으로 사용되는 변수나 정보들이 저장되는 영역
        - PC 레지스터
            - 쓰레드가 시작될 때 생성되며 현재 수행중인 JVM 명령어 주소를 저장
            - 자바 메서드 수행시에만 JVM 명령어 주소를 PC 레지스터에 저장
        - 네이티브 메서드 스택
            - 기계어로 작성된 프로그램 또는 자바 이외의 언어로 작성된 네이티브 코드를 실행하기 위한 공간
            - JIT 컴파일러 의해 변환된 네이티브 코드 역시 여기서 실행
![img_4.png](img%2Fimg_4.png)  
3. JVM, JRE, JDK  
![img_5.png](img%2Fimg_5.png)
   1. JDK (Java Development Kit) : 개발자들이 자바로 개발하는 데 사용되는 소프트웨어 개발 키트
   2. JRE (Java Runtime Environment) : 자바 프로그램 실행시 필요한 라이브러리 API를 함께 묶어서 배포되는 패키지
   3. JVM (Java Virtual Machine) : 자바 실행 프로그램


참조 및 사진 출처 : https://bradbury.tistory.com/226,
https://inpa.tistory.com/entry/JAVA-☕-JVM-내부-구조-메모리-영역-심화편#자바_가상_머신jvm의_동작_방식,
https://inpa.tistory.com/entry/JAVA-☕-JDK-JRE-JVM-개념-구성-원리-💯-완벽-총정리#jvm_java_virtual_machine