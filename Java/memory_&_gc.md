# 자바의 메모리 관리 및 GC

## 1. 자바의 메모리 관리

자바는 자동 메모리 관리 기능을 제공하기 때문에 개발자가 메모리의 할당과 해제를 직접 관리하지 않아도 되는 고급 언어에 속한다. 대표적인 예시가 후술할 자바의 **가비지 컬렉션(Garbage Collection)** 으로 참조되지 않는 객체를 자동으로 정리한다.

자바의 메모리 관리는 동적으로 할당된 객체가 저장되는 **힙(heap) 영역**과 메소드 호출 및 지역 변수 등을 저장하는 **스택(stack) 영역**으로 나뉘는데 이 중 힙의 메모리 설정과 관련된 옵션으로 **Xmx**와 **Xms**가 있다.

<p align="center">
<img src="./img/1.png" alt="img1" />
</p>

### Xmx & Xms

우선 Xms는 초기 힙 메모리 크기를 지정하며, JVM이 시작될 때 할당하는 힙 메모리의 크기를 설정한다. Xmx는 최대 힙 메모리 크기를 지정하며, JVM이 앱 실행 중에 할당할 수 있는 최대 힙 메모리의 크기를 설정한다.

이 두 설정이 필요한 이유는 JVM이 기본적으로 메모리가 부족하게 되면 OS에 메모리를 추가 요청하는 방식으로 힙 사이즈를 조정하기 때문이다. 이때 GC가 발생하게 되고, JVM은 필요한 만큼 힙사이즈를 늘려가게 된다.

이렇게 조정하다가 만약 머신의 물리 메모리 사이즈를 넘어가게 되면 가상 메모리를 사용하면서 swap space로 swap in - out 을 하게 되고, 이는 추후 성능의 문제로 이어질 수 있다.

```java
java -Xms2048m -Xmx2048m -jar app.jar
```
위와 같은 명령어를 통해 `app.jar` 앱을 실행할 때, 초기 메모리 및 최대 메모리 설정을 직접 지정해줄 수 있다.

## 2. 가비지 컬렉션(GC)

<p align="center">
<img src="./img/2.png" alt="img1" />
</p>


앞서 말했듯, GC는 JVM의 Heap 영역에서 동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체(garbage)를 모아 주기적으로 제거하는 프로세스다.

여기서 더 이상 필요없는 객체의 예시는 아래와 같다.

```java
for (int i = 0; i < 10000; i++) {
  NewObject obj = new NewObject();  
  
  // 작업 실행...
}
```

반복문 내부의 `NewObject` 인스턴스들은 10000번 생성돼서 사용되나 반복문이 종료되면 쓸 일이 없이 메모리 공간만을 점유하게 된다. 이때, GC의 동작으로 해당 인스턴스가 점유하는 메모리를 정리하게 된다.

<p align="center">
<img src="./img/3.png" alt="img1" />
</p>


GC의 대상이 되는 객체라 함은, **참조하지 않는 객체**라고 요약할 수 있다. 힙 영역에서 객체들이 실질적으로 생성되고 스택 영역 혹은 메소드 영역에서 해당 객체들의 참조 변수들이 생성된다. 이후 이벤트 종료로 참조 변수가 삭제돼서 붕뜬 객체들이 곧 참조하고 있지 않는 상태가 된다. 이것들이 곧 주기적인 GC 대상이다.

메모리를 자동적으로 정리해주는 점에서 개발자는 개발에만 집중할 수 있지만, 큰 단점이 존재한다. **바로 가비지 컬렉터가 언제 동작하는지 알 수 없다는 점이다.** 또한, 가비지 컬렉터가 동작하는 시점에 **다른 동작을 멈추기 떄문에 오버헤드 발생 가능성이 존재한다.***(전문 용어로 stop the world)

### GC 동작 방식

자바 힙메모리에는 객체의 생명주기를 기준으로 다양한 영역으로 나뉜다.

>- Old
>- Young
>    - Eden
>    - Survival 0
>    - Survival 1

Young 영역에서 발생하는 GC를 **Minor GC**, Old 영역에서 발생하는 GC를 **Major GC**라고 한다.

<p align="center">
<img src="./img/4.gif" alt="img1" />
</p>


기본적으로 GC는 **stop the world(기타 다른 동작들 전부 중단)** 를 일으키고, **mark and sweep(사용 여부 식별 및 메모리 해제)** 을 수행하는데, 처음 생성된 객체는 Young Generation 영역의 일부인 Eden 영역에 위치하다가 Eden이 꽉 차면 Minor GC가 발생한다.

여기서 살아남은 객체들은 Survival 영역으로 옮겨지고 해당 객체들의 생존값이 +1이 된다. Survival 영역이 두 개인 이유는 향후의 Minor GC가 발생했을 때, 그 대상이 되는 영역이 객체가 존재하는 Survival 영역도 포함되기 때문이다.

<p align="center">
<img src="./img/5.gif" alt="img1" />
</p>

O앞서 객체가 살아남을 때마다 생존값이 +1이 되고 이것이 임계값에 도달하면 Old 영역으로 옮겨지게 되고, Old 영역이 꽉 차면 Major GC가 발생한다.

Major GC는 데이터가 가득 차면 GC를 실행하는 단순한 방식이며, Old 영역이 상대적으로 큰 공간을 갖고 있기 때문에 GC 실행에 있어 Minor GC보다 많은 시간이 걸리고 이 부분에서 stop the world 문제가 발생할 수 있다.
